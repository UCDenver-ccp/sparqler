;; Analyzed by ClojureScript 0.0-3211
{:use-macros nil, :excludes #{}, :name matsu_compiler, :imports nil, :requires {string clojure.string, clojure.string clojure.string, clojure.walk clojure.walk, matsu_core matsu_core}, :uses {prefixes matsu_core, postwalk-replace clojure.walk, ns-or-error matsu_core}, :defs {sub-compiler {:protocol-inline nil, :meta {:file "/Users/dcmcshan/Clones/sparqler/src/cljstest/matsu_compiler.cljc", :line 81, :column 8, :end-line 81, :end-column 20, :private true, :arglists (quote ([m]))}, :private true, :name matsu_compiler/sub-compiler, :variadic false, :file "src/cljstest/matsu_compiler.cljc", :end-column 20, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 81, :end-line 81, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :test true}, escape-str {:protocol-inline nil, :meta {:file "/Users/dcmcshan/Clones/sparqler/src/cljstest/matsu_compiler.cljc", :line 15, :column 7, :end-line 15, :end-column 17, :arglists (quote ([s])), :doc "esacpes double quotes in strings"}, :name matsu_compiler/escape-str, :variadic false, :file "src/cljstest/matsu_compiler.cljc", :end-column 17, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 15, :end-line 15, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "esacpes double quotes in strings", :test true}, encode {:protocol-inline nil, :meta {:file "/Users/dcmcshan/Clones/sparqler/src/cljstest/matsu_compiler.cljc", :line 20, :column 7, :end-line 20, :end-column 13, :arglists (quote ([x])), :doc "Encodes keywords to ?-prefixed variables and other values to RDF literals\n  when applicable.\n\n  Vectors are interpreted differently according to their contents:\n\n    [keyword keyword] => prefixed name\n    [string string]   => literal^^string (typed literal)\n    [string keyword]  => string with language tag\n    [keyword]         => <keyword> - to be used with BASE\n    [map keyword]     => (:content map) AS keyword\n    [[:keyword]]      => _:keyword (blank node)\n    [[]]              => []\n\n  Maps are expaned and compiled according to its contents, tag, bounds and\n  separator"}, :name matsu_compiler/encode, :variadic false, :file "src/cljstest/matsu_compiler.cljc", :end-column 13, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 20, :end-line 20, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Encodes keywords to ?-prefixed variables and other values to RDF literals\n  when applicable.\n\n  Vectors are interpreted differently according to their contents:\n\n    [keyword keyword] => prefixed name\n    [string string]   => literal^^string (typed literal)\n    [string keyword]  => string with language tag\n    [keyword]         => <keyword> - to be used with BASE\n    [map keyword]     => (:content map) AS keyword\n    [[:keyword]]      => _:keyword (blank node)\n    [[]]              => []\n\n  Maps are expaned and compiled according to its contents, tag, bounds and\n  separator", :test true}, replacement-map {:name matsu_compiler/replacement-map, :file "src/cljstest/matsu_compiler.cljc", :line 73, :column 1, :end-line 73, :end-column 21, :test true, :meta {:file "/Users/dcmcshan/Clones/sparqler/src/cljstest/matsu_compiler.cljc", :line 73, :column 6, :end-line 73, :end-column 21}, :doc "Used to replace clojure fn symbols with characters inside expressions"}, compiler {:protocol-inline nil, :meta {:file "/Users/dcmcshan/Clones/sparqler/src/cljstest/matsu_compiler.cljc", :line 77, :column 8, :end-line 77, :end-column 16, :private true, :arglists (quote ([q part]))}, :private true, :name matsu_compiler/compiler, :variadic false, :file "src/cljstest/matsu_compiler.cljc", :end-column 16, :method-params ([q part]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 77, :end-line 77, :max-fixed-arity 2, :fn-var true, :arglists (quote ([q part])), :test true}, infer-prefixes {:protocol-inline nil, :meta {:file "/Users/dcmcshan/Clones/sparqler/src/cljstest/matsu_compiler.cljc", :line 93, :column 8, :end-line 93, :end-column 22, :private true, :arglists (quote ([m s])), :doc "Finds all occurences of the pattern 'prefix:name' in the query string.\n  Returns the query string with the namespaces prefixed."}, :private true, :name matsu_compiler/infer-prefixes, :variadic false, :file "src/cljstest/matsu_compiler.cljc", :end-column 22, :method-params ([m s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 93, :end-line 93, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m s])), :doc "Finds all occurences of the pattern 'prefix:name' in the query string.\n  Returns the query string with the namespaces prefixed.", :test true}, add-base {:protocol-inline nil, :meta {:file "/Users/dcmcshan/Clones/sparqler/src/cljstest/matsu_compiler.cljc", :line 104, :column 8, :end-line 104, :end-column 16, :private true, :arglists (quote ([uri s])), :doc "Prefixes the query string with 'BASE <uri>'"}, :private true, :name matsu_compiler/add-base, :variadic false, :file "src/cljstest/matsu_compiler.cljc", :end-column 16, :method-params ([uri s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 104, :end-line 104, :max-fixed-arity 2, :fn-var true, :arglists (quote ([uri s])), :doc "Prefixes the query string with 'BASE <uri>'", :test true}, compile-query {:protocol-inline nil, :meta {:file "/Users/dcmcshan/Clones/sparqler/src/cljstest/matsu_compiler.cljc", :line 113, :column 7, :end-line 113, :end-column 20, :arglists (quote ([q])), :doc "Takes a map representing SPARQL graph patterns, bindings and modifiers and\n  returns a vaild SPARQL 1.1 query string"}, :name matsu_compiler/compile-query, :variadic false, :file "src/cljstest/matsu_compiler.cljc", :end-column 20, :method-params ([q]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 113, :end-line 113, :max-fixed-arity 1, :fn-var true, :arglists (quote ([q])), :doc "Takes a map representing SPARQL graph patterns, bindings and modifiers and\n  returns a vaild SPARQL 1.1 query string", :test true}}, :require-macros nil, :cljs.analyzer/constants {:seen #{:having :sep :insert :where :local-prefixes :limit :group-by :else :offset :content :delete :bounds :prefix :from-named :with :from :values :order-by :tag :query-form :base :select}, :order [:else :tag :content :bounds :sep :base :local-prefixes :prefix :query-form :from :from-named :with :delete :insert :select :values :where :order-by :limit :offset :group-by :having]}, :doc "Compiles the query-map into a valdid SPARQL 1.1 string"}